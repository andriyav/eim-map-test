{"uid":"4ad3191dd86f2ff6","name":"test_co_list_agent_preferred_phone","fullName":"tests.test_checklist.TestPromotionChecklist#test_co_list_agent_preferred_phone","historyId":"72cbc0b3c0fb08f51188c49c6c405858","time":{"start":1739312283844,"stop":1739312286353,"duration":2509},"description":"A decorator for applying a mark on test functions and classes.\n\n``MarkDecorators`` are created with ``pytest.mark``::\n\n    mark1 = pytest.mark.NAME  # Simple MarkDecorator\n    mark2 = pytest.mark.NAME(name1=value)  # Parametrized MarkDecorator\n\nand can then be applied as decorators to test functions::\n\n    @mark2\n    def test_function():\n        pass\n\nWhen a ``MarkDecorator`` is called, it does the following:\n\n1. If called with a single class as its only positional argument and no\n   additional keyword arguments, it attaches the mark to the class so it\n   gets applied automatically to all test cases found in that class.\n\n2. If called with a single function as its only positional argument and\n   no additional keyword arguments, it attaches the mark to the function,\n   containing all the arguments already stored internally in the\n   ``MarkDecorator``.\n\n3. When called in any other case, it returns a new ``MarkDecorator``\n   instance with the original ``MarkDecorator``'s content updated with\n   the arguments passed to this call.\n\nNote: The rules above prevent a ``MarkDecorator`` from storing only a\nsingle function or class reference as its positional argument with no\nadditional keyword or positional arguments. You can work around this by\nusing `with_args()`.\n","descriptionHtml":"<p>A decorator for applying a mark on test functions and classes.</p>\n<p><code>MarkDecorators</code> are created with <code>pytest.mark</code>::</p>\n<pre><code>mark1 = pytest.mark.NAME  # Simple MarkDecorator\nmark2 = pytest.mark.NAME(name1=value)  # Parametrized MarkDecorator\n</code></pre>\n<p>and can then be applied as decorators to test functions::</p>\n<pre><code>@mark2\ndef test_function():\n    pass\n</code></pre>\n<p>When a <code>MarkDecorator</code> is called, it does the following:</p>\n<ol>\n<li>\n<p>If called with a single class as its only positional argument and no<br />\nadditional keyword arguments, it attaches the mark to the class so it<br />\ngets applied automatically to all test cases found in that class.</p>\n</li>\n<li>\n<p>If called with a single function as its only positional argument and<br />\nno additional keyword arguments, it attaches the mark to the function,<br />\ncontaining all the arguments already stored internally in the<br />\n<code>MarkDecorator</code>.</p>\n</li>\n<li>\n<p>When called in any other case, it returns a new <code>MarkDecorator</code><br />\ninstance with the original <code>MarkDecorator</code>'s content updated with<br />\nthe arguments passed to this call.</p>\n</li>\n</ol>\n<p>Note: The rules above prevent a <code>MarkDecorator</code> from storing only a<br />\nsingle function or class reference as its positional argument with no<br />\nadditional keyword or positional arguments. You can work around this by<br />\nusing <code>with_args()</code>.</p>\n","status":"passed","flaky":false,"newFailed":false,"newBroken":false,"newPassed":false,"retriesCount":0,"retriesStatusChange":false,"beforeStages":[{"name":"_unittest_setUpClass_fixture_TestPromotionChecklist","time":{"start":1739312125785,"stop":1739312125785,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false}],"testStage":{"description":"A decorator for applying a mark on test functions and classes.\n\n``MarkDecorators`` are created with ``pytest.mark``::\n\n    mark1 = pytest.mark.NAME  # Simple MarkDecorator\n    mark2 = pytest.mark.NAME(name1=value)  # Parametrized MarkDecorator\n\nand can then be applied as decorators to test functions::\n\n    @mark2\n    def test_function():\n        pass\n\nWhen a ``MarkDecorator`` is called, it does the following:\n\n1. If called with a single class as its only positional argument and no\n   additional keyword arguments, it attaches the mark to the class so it\n   gets applied automatically to all test cases found in that class.\n\n2. If called with a single function as its only positional argument and\n   no additional keyword arguments, it attaches the mark to the function,\n   containing all the arguments already stored internally in the\n   ``MarkDecorator``.\n\n3. When called in any other case, it returns a new ``MarkDecorator``\n   instance with the original ``MarkDecorator``'s content updated with\n   the arguments passed to this call.\n\nNote: The rules above prevent a ``MarkDecorator`` from storing only a\nsingle function or class reference as its positional argument with no\nadditional keyword or positional arguments. You can work around this by\nusing `with_args()`.\n","status":"passed","steps":[],"attachments":[{"uid":"94412e5d7b975024","name":"log","source":"94412e5d7b975024.txt","type":"text/plain","size":360}],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":1,"hasContent":true,"attachmentStep":false},"afterStages":[{"name":"_unittest_setUpClass_fixture_TestPromotionChecklist::0","time":{"start":1739315514556,"stop":1739315514557,"duration":1},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false}],"labels":[{"name":"parentSuite","value":"tests"},{"name":"suite","value":"test_checklist"},{"name":"subSuite","value":"TestPromotionChecklist"},{"name":"host","value":"fv-az1280-128"},{"name":"thread","value":"3364-MainThread"},{"name":"framework","value":"pytest"},{"name":"language","value":"cpython3"},{"name":"package","value":"tests.test_checklist"},{"name":"resultFormat","value":"allure2"}],"parameters":[],"links":[],"hidden":false,"retry":false,"extra":{"severity":"normal","retries":[],"categories":[],"tags":[]},"source":"4ad3191dd86f2ff6.json","parameterValues":[]}